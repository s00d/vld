//! # vld-utoipa — Bridge between `vld` and `utoipa`
//!
//! This crate lets you use `vld` validation schemas as the **single source of truth**
//! for both runtime validation and OpenAPI documentation generated by
//! [utoipa](https://docs.rs/utoipa).
//!
//! Instead of duplicating schema definitions with `#[derive(ToSchema)]` **and**
//! `vld::schema!`, you define validation rules once in `vld` and get `utoipa`
//! compatibility for free.
//!
//! # Quick Start
//!
//! ```rust
//! use vld::prelude::*;
//! use vld_utoipa::impl_to_schema;
//!
//! // 1. Define your validated struct as usual
//! vld::schema! {
//!     #[derive(Debug)]
//!     pub struct User {
//!         pub name: String => vld::string().min(2).max(50),
//!         pub email: String => vld::string().email(),
//!     }
//! }
//!
//! // 2. Bridge to utoipa — one line
//! impl_to_schema!(User);
//!
//! // Now `User` implements `utoipa::ToSchema` and can be used in
//! // `#[utoipa::path]` annotations.
//! ```
//!
//! # Converting arbitrary JSON Schema
//!
//! ```rust
//! use vld_utoipa::json_schema_to_schema;
//!
//! let json_schema = serde_json::json!({
//!     "type": "object",
//!     "required": ["name"],
//!     "properties": {
//!         "name": { "type": "string", "minLength": 1 }
//!     }
//! });
//!
//! let utoipa_schema = json_schema_to_schema(&json_schema);
//! // Returns `utoipa::openapi::RefOr<utoipa::openapi::schema::Schema>`
//! ```

use serde_json::Value;
use utoipa::openapi::schema::{
    AllOf, Array, Object, OneOf, Schema, SchemaFormat, SchemaType, Type,
};
use utoipa::openapi::{Ref, RefOr};

/// Convert a `serde_json::Value` (JSON Schema) produced by `vld` into a
/// `utoipa::openapi::RefOr<Schema>`.
///
/// This is the core conversion function. It handles:
/// - Primitive types: `string`, `number`, `integer`, `boolean`, `null`
/// - Objects with `properties` and `required`
/// - Arrays with `items`
/// - `oneOf`, `allOf` composites
/// - `enum` values
/// - Numeric constraints: `minimum`, `maximum`, `exclusiveMinimum`, `exclusiveMaximum`, `multipleOf`
/// - String constraints: `minLength`, `maxLength`, `pattern`
/// - Array constraints: `minItems`, `maxItems`
/// - `format`, `description`, `default`, `example`
/// - `$ref` references
///
/// # Example
///
/// ```rust
/// use vld_utoipa::json_schema_to_schema;
///
/// let schema = json_schema_to_schema(&serde_json::json!({"type": "string", "format": "email"}));
/// ```
pub fn json_schema_to_schema(value: &Value) -> RefOr<Schema> {
    match value {
        Value::Object(map) => {
            // Handle $ref
            if let Some(Value::String(ref_path)) = map.get("$ref") {
                return RefOr::Ref(Ref::new(ref_path.clone()));
            }

            // Handle oneOf
            if let Some(Value::Array(items)) = map.get("oneOf") {
                let schemas: Vec<RefOr<Schema>> = items.iter().map(json_schema_to_schema).collect();
                let mut one_of = OneOf::new();
                one_of.items = schemas;
                return RefOr::T(Schema::OneOf(one_of));
            }

            // Handle allOf
            if let Some(Value::Array(items)) = map.get("allOf") {
                let schemas: Vec<RefOr<Schema>> = items.iter().map(json_schema_to_schema).collect();
                let mut all_of = AllOf::new();
                all_of.items = schemas;
                return RefOr::T(Schema::AllOf(all_of));
            }

            // Determine type
            let type_str = map.get("type").and_then(|v| v.as_str()).unwrap_or("object");

            match type_str {
                "array" => {
                    let items_schema = map
                        .get("items")
                        .map(json_schema_to_schema)
                        .unwrap_or_else(|| RefOr::T(Schema::Object(Object::default())));

                    let mut arr = Array::new(items_schema);

                    if let Some(n) = map.get("minItems").and_then(|v| v.as_u64()) {
                        arr.min_items = Some(n as usize);
                    }
                    if let Some(n) = map.get("maxItems").and_then(|v| v.as_u64()) {
                        arr.max_items = Some(n as usize);
                    }

                    RefOr::T(Schema::Array(arr))
                }
                "object" => convert_object(map),
                _ => convert_primitive(map, type_str),
            }
        }
        // Bare true/false schema
        Value::Bool(true) => RefOr::T(Schema::Object(Object::new())),
        _ => RefOr::T(Schema::Object(Object::default())),
    }
}

fn convert_object(map: &serde_json::Map<String, Value>) -> RefOr<Schema> {
    let mut obj = Object::with_type(SchemaType::Type(Type::Object));

    // Properties
    if let Some(Value::Object(props)) = map.get("properties") {
        for (key, val) in props {
            obj.properties
                .insert(key.clone(), json_schema_to_schema(val));
        }
    }

    // Required
    if let Some(Value::Array(req)) = map.get("required") {
        obj.required = req
            .iter()
            .filter_map(|v| v.as_str().map(String::from))
            .collect();
    }

    // Description
    if let Some(Value::String(desc)) = map.get("description") {
        obj.description = Some(desc.clone());
    }

    // Title
    if let Some(Value::String(title)) = map.get("title") {
        obj.title = Some(title.clone());
    }

    // Default
    if let Some(default) = map.get("default") {
        obj.default = Some(default.clone());
    }

    // Example
    if let Some(example) = map.get("example") {
        obj.example = Some(example.clone());
    }

    RefOr::T(Schema::Object(obj))
}

fn to_number(n: f64) -> utoipa::Number {
    if n.fract() == 0.0 {
        utoipa::Number::Int(n as isize)
    } else {
        utoipa::Number::Float(n)
    }
}

fn convert_primitive(map: &serde_json::Map<String, Value>, type_str: &str) -> RefOr<Schema> {
    let schema_type = match type_str {
        "string" => SchemaType::Type(Type::String),
        "number" => SchemaType::Type(Type::Number),
        "integer" => SchemaType::Type(Type::Integer),
        "boolean" => SchemaType::Type(Type::Boolean),
        "null" => SchemaType::Type(Type::Null),
        _ => SchemaType::Type(Type::Object),
    };

    let mut obj = Object::with_type(schema_type);

    // Format
    if let Some(Value::String(fmt)) = map.get("format") {
        obj.format = Some(SchemaFormat::Custom(fmt.clone()));
    }

    // Description
    if let Some(Value::String(desc)) = map.get("description") {
        obj.description = Some(desc.clone());
    }

    // Title
    if let Some(Value::String(title)) = map.get("title") {
        obj.title = Some(title.clone());
    }

    // Default
    if let Some(default) = map.get("default") {
        obj.default = Some(default.clone());
    }

    // Example
    if let Some(example) = map.get("example") {
        obj.example = Some(example.clone());
    }

    // Enum values
    if let Some(Value::Array(vals)) = map.get("enum") {
        obj.enum_values = Some(vals.clone());
    }

    // Pattern (string)
    if let Some(Value::String(pat)) = map.get("pattern") {
        obj.pattern = Some(pat.clone());
    }

    // String constraints
    if let Some(n) = map.get("minLength").and_then(|v| v.as_u64()) {
        obj.min_length = Some(n as usize);
    }
    if let Some(n) = map.get("maxLength").and_then(|v| v.as_u64()) {
        obj.max_length = Some(n as usize);
    }

    // Numeric constraints
    if let Some(n) = map.get("minimum").and_then(|v| v.as_f64()) {
        obj.minimum = Some(to_number(n));
    }
    if let Some(n) = map.get("maximum").and_then(|v| v.as_f64()) {
        obj.maximum = Some(to_number(n));
    }
    if let Some(n) = map.get("exclusiveMinimum").and_then(|v| v.as_f64()) {
        obj.exclusive_minimum = Some(to_number(n));
    }
    if let Some(n) = map.get("exclusiveMaximum").and_then(|v| v.as_f64()) {
        obj.exclusive_maximum = Some(to_number(n));
    }
    if let Some(n) = map.get("multipleOf").and_then(|v| v.as_f64()) {
        obj.multiple_of = Some(to_number(n));
    }

    RefOr::T(Schema::Object(obj))
}

/// Implement `utoipa::PartialSchema` and `utoipa::ToSchema` for a type that
/// has a `json_schema()` associated function (generated by `vld::schema!` with
/// the `openapi` feature enabled).
///
/// # Usage
///
/// ```rust
/// use vld::prelude::*;
/// use vld_utoipa::impl_to_schema;
///
/// vld::schema! {
///     #[derive(Debug)]
///     pub struct CreateUser {
///         pub name: String => vld::string().min(2).max(100),
///         pub email: String => vld::string().email(),
///     }
/// }
///
/// impl_to_schema!(CreateUser);
///
/// // Now you can use CreateUser in utoipa annotations:
/// // #[utoipa::path(post, path = "/users", request_body = CreateUser)]
/// ```
///
/// You can also pass a custom schema name:
///
/// ```rust
/// # use vld::prelude::*;
/// # use vld_utoipa::impl_to_schema;
/// # vld::schema! {
/// #     #[derive(Debug)]
/// #     pub struct Req { pub x: String => vld::string() }
/// # }
/// impl_to_schema!(Req, "CreateUserRequest");
/// ```
#[macro_export]
macro_rules! impl_to_schema {
    ($ty:ty) => {
        impl $crate::utoipa::PartialSchema for $ty {
            fn schema() -> $crate::utoipa::openapi::RefOr<$crate::utoipa::openapi::schema::Schema> {
                $crate::json_schema_to_schema(&<$ty>::json_schema())
            }
        }

        impl $crate::utoipa::ToSchema for $ty {}
    };
    ($ty:ty, $name:expr) => {
        impl $crate::utoipa::PartialSchema for $ty {
            fn schema() -> $crate::utoipa::openapi::RefOr<$crate::utoipa::openapi::schema::Schema> {
                $crate::json_schema_to_schema(&<$ty>::json_schema())
            }
        }

        impl $crate::utoipa::ToSchema for $ty {
            fn name() -> ::std::borrow::Cow<'static, str> {
                ::std::borrow::Cow::Borrowed($name)
            }
        }
    };
}

/// Re-export utoipa for use in macros
pub use utoipa;

/// Prelude module — import everything you need.
pub mod prelude {
    pub use crate::impl_to_schema;
    pub use crate::json_schema_to_schema;
    pub use vld::prelude::*;
}
